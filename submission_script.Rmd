---
title: "Cancer histology prediction challenge 2.0 (histpred2.0)"
subtitle: "COMPTE RENDU"
author: "RAMDÉ Ismaïl - MCKENNA Kevin - EL Hadrami N'DOYE"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 2
params:
  package_repository: "https://cloud.r-project.org"
  install_dependencies: true
---

# Package dependencies
- zip : to generate the zip files that contain the programs or the results to submit to the Codalab platform.

```{r label = "Submission - dependencies", include = FALSE}
if ( !exists(x = "params") ) {
    params                      <- NULL
}
if ( is.null(x = params$package_repository) ) {
    params$package_repository   <- "https://cloud.r-project.org"
}
if ( is.null(x = params$install_dependencies) ) {
    params$install_dependencies <- TRUE
}
print(params)
if ( params$install_dependencies ) {
    installed_packages <- installed.packages( )
    for (package in c("zip") ) {
        if ( !{ package %in% installed_packages } ) {
            print(x = paste("Installation of ", package, sep = "") )
            install.packages(
                pkgs = package
              , repos = params$package_repository
            )
        } else {
            print(x = paste(package, " is installed.", sep = "") )
        }
    }
    remove(list = c("installed_packages", "package") )
}
```

# Format of the submission

- **For a code submission** : you have to make a zip file (no constrain on the namefile) that contains :
  - the file `metadata` that is generated by this script
  - your code inside a *R* file named `program.R`. This file will be sourced and have to contain :
    - a function `program` with `data_train` and `data_test` as argument : a matrix associated to your estimation.
  - any other files that you want to access from your function `program` : during the ingestion phase (when your code is evaluated), the working directory will be inside the directory obtained by unzipping your submission.
  
- **For a result submission** : you have to make a zip file (no constrain on the namefile), with your results as a matrix inside a rds file named `results.txt`.


# Configuration of your result

```{r label = "Submission - configuration", echo = TRUE, results = "verbatim"}
    ##
    ## EDIT THE FOLLOWING CODE BY COMMENTING/UNCOMMENTING THE REQUIRED PARTS
    ##
    
    ## define the public data set that you will use for your estimation :
    data_train <- readRDS(file = "data_train.rds")
    data_test <- readRDS(file = "data_test.rds")
    
```

# Statistique descriptive
Nous commençons notre étude par une brève statistique descriptive afin de comprendre 
au mieux nos données ainsi que voir leur nature.
```{r}
# Dimensions
dim(data_train)
dim(data_test)
# Apperçu des données
head(data_train[,1:5])
```


```{r}
# Table de l'histologie et du sexe
table(data_train$histology)
table(data_train$sex)
```

## Diagramme en bâton
```{r}
library(ggplot2)
ggplot(data_train, aes(x=as.numeric(factor(histology)), fill=sex))+
  geom_bar(position=position_dodge())+
  scale_fill_brewer(palette="Blues")+
  labs(title="Diagramme en bâton histology en fonction de sex",
        x ="histology") +
  theme_minimal()
```



## Distribution de l’expression de l'histologie (en fonction du sexe) dans la `data_train`

```{r}
library(ggplot2)
histology = as.numeric(factor(data_train$histology))
#layout(matrix(1:2, 1), respect=TRUE)
ggplot(data_train, aes(x=as.numeric(factor(histology)), color=sex)) +
  geom_density() +
  xlim(0,3)
# Ajouter les moyennes
```

La figure ci-dessus illustre la densité de la variable 'histology' avec la part des hommes et des femmes.


# Les méthodes de prédiction de la variable 'histologie'

Dans ce projet nous utilisons essentiellement trois méthodes : 2 méthodes manuelles basées sur le $R²$
et les p-valeurs. Et une selection de variable.
Dans les ligne qui suivent nous évaluérons l'efficacité de chacune d'elle.

## Méthode 1 (Les P-valeurs les plus significatifs au desssus du seuil 30)
**Volcano plot**
...
la méthode consiste a construire le volcano plot de toutes les variables avec leur $\beta_{gene}$ en fonction de leur $-log10(p-valeur)$ du test de Wald.
Les plus petites se situent en haut du graphique car nous avons les avons pris en $-log10$.
Nous decidons de fixer un seuil à 30 et retenons les variables situées au-dessus. On obtient les gènes suivants : CNTLN, TARBP1, MCM6, DHPS, AGFG2, WNT3, PCDHB3, S100PBP, PYROXD2, TEK, FABP3, SLC52A1, GLS2, GRHPR, NCOA2, SELENBP1, CCDC150, GLRA1, WTAP, BEND6, PXYLP1, PAQR3, SLC6A20, TEKT1, CTRB1, ARMC4, ZNF454, PRKAG1, AFAP1, TMEM116, SNORD114_3, ST7_AS1, KRT16P2, FAM225A, ZEB1_AS1, TUNAR, FCGBP, MARCKS.


## Méthode 2 (basée sur les R² les plus significatifs)
**Volcano plot**
...
Nous avons d'abord classés les p-valeurs issues du test de Wald des différentes variable par ordre croissant. En suite nous decidons de selectionner les 50 premiers et calculons les les $R²$ pour chaque modèle.
Sur le graphique on peut voir des sauts significatif de $R²$ des certains gènes. Ce sont ces gènes qui contribuent significativement à la prediction de la variable 'histology'.
Nous retenons donc les gènes : TINCR, PTHLH, UMPS, ALDH3B1, FRRS1, TOX3, ABCC6P1, HRAS, SYNCRIP, RNF185, NCK1, BCL11A, ZC3H8, MBIP, ELFN2, WDR72, TMTC1, JOSD1, MN1, EHD3.

## Méthode 3 (Selection de variables)
...


# Write a function to estimate the parameters of mean and covariance

In the provided example, we use the empirical estimations of the mean and covariance.

```{r label = "Submission - Program", echo = TRUE, results = "verbatim"}
#' The function to estimate the mean and covariance parameters
#'
#' @param data_train a matrix
#' @param data_test a matrix
#' @return the estimated parameters
#' @examples
#' program(data_train = data_train, data_test = data_test)
program <- function(data_train, data_test) {
    gs = colnames(data_test)[-(1:3)]
    data_pred = data_test[,"histology"]
    names(data_pred) = rownames(data_test)
    data_train$histology = as.factor(data_train$histology)
    data_test$histology  = as.factor(data_test$histology )

    ##
    ## YOUR CODE BEGINS HERE
    

    
    
    # use the first gene as predictor for histology
    g = gs[1] 
    plot(data_train$histology, data_train[,g])
    formula = as.formula(paste0("histology~", g))
    print(formula)
    m = glm(formula, data_train, family =binomial(link = 'logit'))
    pred = predict.glm(m, data_test, type="response")    
    data_pred = ifelse(pred<0.5, "AD", "SC")


    # get gene with best logistic regression model as predictor for histology
    ms = sapply(gs, function(g){
      # print(g)
      formula = as.formula(paste0("histology~", g))
      m = glm(formula, data_train, family =binomial(link = 'logit'))
      
      pval = summary(m)$coefficients[2,4]
      beta = m$coefficients[[2]]
      return(c(pval=pval, beta=beta))
    })
    # estBeta <- summary(m)$coefficients[,1]
    # varBeta <- summary(m)$cov.unscaled
    # wald.test(Sigma = varBeta, b = estBeta, Terms = 500)
    plot(ms["beta",], -log10(ms["pval",]))
    g = colnames(ms[,order(ms["pval",])])[1:50]
    # tt = -log10(ms["pval",])
    # t = sort(tt)[1:50]
    # plot(t, col="red",main = "les 50 p-valeurs triées par ordre croissant")
    
    
    # 1. Méthode 1 (R2 les plus significatifs)
    ###########################################################################
    tt = (ms["pval",])
    tt
    sis_genes = names(sort(tt))
    R2 <- c()
    for(i in 1:50){
      formula2 <- as.formula(paste0("histology~",paste0(sis_genes[1:i],collapse="+")))
      model = glm(formula2,data_train,  family = binomial(logit))
      R2 <- c(R2, 1-(model$deviance/model$null.deviance))
    }
    layout(1, respect=TRUE)
    plot(1:50,R2,type="b",xlab="Nombre de gênes",main="R^2 en fonction du nombre de gênes sélectionnés")
    abline(v=3,lty=2,col=2)
    abline(v=4,lty=2,col=2)
    abline(v=5,lty=2,col=2)
    abline(v=7,lty=2,col=2)
    abline(v=8,lty=2,col=2)
    abline(v=9,lty=2,col=2)
    abline(v=15,lty=2,col=2)
    abline(v=20,lty=2,col=2)
    abline(v=26,lty=2,col=2)
    abline(v=27,lty=2,col=2)
    abline(v=37,lty=2,col=2)
    abline(v=46,lty=2,col=2)
    abline(v=44,lty=2,col=2)
    abline(v=43,lty=2,col=2)
    abline(v=43,lty=2,col=2)
    
    formula3 <- as.formula(paste0("histology~age+sex+",paste0(sis_genes[c(1:5,7,8,9,15,20,26,27,37,40,41,42,43,44,46,56)],collapse="+"))) 
    print(formula3)
    model2 <- glm(formula3,data_train,  family = binomial(logit))
    R_carre1 = 1-(model2$deviance/model2$null.deviance)
    R_carre1 # 0.9032166 et 4.0 sur Codalab
    ############
    
    
    # 2. Méthode 2 (Les Pvaleurs les plus significatifs au desssus du seuil 30)
    ############################################################################
    beta = ms["beta",]
    layout(1, respect=TRUE)
    plot(beta, -log10(tt), col="grey")
    idx = -log10(tt) > 30
    text(beta[idx], -log10(tt[idx]), names(beta[idx]))
    
    sis_genes2 = names(beta[idx])
    formula4 <- as.formula(paste0("histology~sex+age+",paste0(sis_genes2,collapse="+"))) 
    print(formula4)
    model3 <- glm(formula4,data_train,  family = binomial(logit))
    R_carre2 = 1-(model3$deviance/model3$null.deviance)
    R_carre2 # 0.9062056 et 0.5 sur codalab
    ##############
    
    
    # 3.Méthode 3 (Selection de variables)
    ####################################################
    nb_sis_genes = 40
    m_lo = glm(histology~1, data=data_train[,c("histology", sis_genes[1:nb_sis_genes])],family=binomial(logit))
    m_up = glm(histology~., data=data_train[,c("histology", sis_genes[1:nb_sis_genes])],family=binomial(logit))
    m_fwd = step(m_lo, dir="forward", scope=list(upper=m_up,lower=m_lo), trace=0)
    
    print(m_fwd$call)
    step_genes = names(m_fwd$coefficients)[-1]
    step_genes  
    
    formula5 = as.formula(histology ~ PTHLH + EIF2B5 + SYNCRIP + RNF185 + 
    ZC3H8 + DNMBP_AS1 + FRRS1 + HRAS + BCL11A + LMO7 + NCK1 + 
    UMPS + MBIP)
    mod <- glm(formula = formula5, family = binomial(logit), data = data_train)
    mod$coefficients
    summary(mod)$coefficient
    z_val = summary(mod)$coefficient[2:7,3]
    statWald = z_val^2
    statWald
    pvalWald1 = 1-pchisq(statWald,1)
    pvalWald1
    rr = 1-(mod$deviance/mod$null.deviance)
    rr #  0.9146519
    ######################################################################"
    
    
    
    ms2 = ms[,order(ms["pval",])]
    g2= ''
    for (i in 1:(length(g)-1)){g2 = paste(g2,g[[i]],' + ')}
    g2 = paste(g2,g[[length(g)]])
    
    
    formula = as.formula(paste0("histology~", g2))
    print(formula)
    m = glm(formula5, data_train, family =binomial(link = 'logit'))
    pred = predict.glm(m, data_test, type="response")
    data_pred = ifelse(pred<0.5, "AD", "SC")
    
  
    
    ##
    ## YOUR CODE ENDS HERE
    ##

    return(data_pred)
    
}
```

# Generate an estimation of the parameters of mean and covariance

```{r label = "Submission - Results", echo = TRUE, results = "verbatim"}
    ##
    ## DO NOT CHANGE THE FOLLOWING CODE
    ##

    ## we use the previously defined function 'program' to estimate A :
    data_pred <- program(
      data_train = data_train,
      data_test = data_test
    )
```

# Generate a zip file with the 'program' source code

```{r label = "Submission - program zip file", echo = TRUE, results = "verbatim"}
if ( !dir.exists(paths = "submissions") ) {
    dir.create(path = "submissions")
}

## we save the source code as a R file named 'program.R' :
dump(
    list = c("program")
  , file = paste0("submissions", .Platform$file.sep, "program.R")
)
## we also generate the 'metadata' file
cat(
    "command: Rscript $program/program.R $input $output"
  , file = paste0("submissions", .Platform$file.sep, "metadata")
)

## we create the associated zip file :
zip_program <- paste0("submissions", .Platform$file.sep, "program_", format(x = Sys.time( ), format = "%Y_%m_%d_%S"), ".zip")
zip::zipr(
         zipfile = zip_program
       , files   = paste0("submissions", .Platform$file.sep, c("program.R", "metadata") )
     )
print(x = zip_program)
```

# Generate a zip file with the estimation of the parameters of mean and covariance

```{r label = "Submission - results zip file", echo = TRUE, results = "verbatim"}
if ( !dir.exists(paths = "submissions") ) {
    dir.create(path = "submissions")
}

## we save the estimated A matrix as a rds file named 'results.txt' :
# saveRDS(
#     object = data_pred
#   , file   = paste0("submissions", .Platform$file.sep, "results.rds")
# )

write.table(
  x=data_pred, 
  file= paste0("submissions", .Platform$file.sep, "results.txt"),
  quote=FALSE,
  row.names=FALSE,
  col.names=FALSE
)


## we create the associated zip file :
zip_results <- paste0("submissions", .Platform$file.sep, "results_", format(x = Sys.time( ), format = "%Y_%m_%d_%S"), ".zip")
zip::zipr(
         zipfile = zip_results
       , files   = paste0("submissions", .Platform$file.sep, c("results.txt") )
     )
print(x = zip_results)
```

# Submit the zip file

It generates the files *`r zip_program`*  and *`r zip_results`*  (the 1st one for code submission, the 2nd one for result submission).

Submit the zip submission file on the challenge in the tab `Participate`, menu `Submit / View Results` menu, sub-menu `CHALLENGE #1`, by clicking the `Submit` button after filling out some metadatas.

On the codalab challenge web page, The *STATUS* become : 
  - Submitting
  - Submitted	
  - Running
  - Finished

When it’s finished :
  - You refresh the page and see your score
  - If enable, details for report could be downloaded by clicking *Download output from scoring step*.
  - Some logs are available to download.
  - Leader board is updated in the `Results` tab.

# Session Information

```{r, results="verbatim"}
sessionInfo( )
```
